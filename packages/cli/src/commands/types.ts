import path from 'node:path';

import { stableStringify } from '@hexmon_tech/compiler';
import type { PolicySet, RolePermission } from '@hexmon_tech/policy-dsl';

import { ensureDir, writeFileAtomic } from '../fs';
import type { CommandContext } from './shared';
import { loadPolicy, printDiagnostics, validateAndCompile } from './shared';

export interface TypesCommandOptions {
  policyPath: string;
  outPath: string;
  mode?: 'single-tenant' | 'multi-tenant';
  context: CommandContext;
}

/** Generate deterministic TypeScript unions/constants from policy definitions. */
export async function runTypesCommand(options: TypesCommandOptions): Promise<number> {
  const mode = options.mode ?? 'single-tenant';
  const loaded = await loadPolicy(options.policyPath, options.context);
  const result = validateAndCompile(loaded.rawPolicy, mode);

  if (result.diagnostics.length > 0) {
    printDiagnostics(result.diagnostics, options.context);
  }

  if (!result.ok || !result.policySet) {
    options.context.io.err(`Type generation failed: invalid policy ${loaded.policyPath}`);
    return 1;
  }

  const output = generatePolicyTypes(result.policySet, loaded.rawPolicy);
  const resolvedOut = path.resolve(options.context.cwd, options.outPath);

  await ensureDir(path.dirname(resolvedOut));
  await writeFileAtomic(resolvedOut, output);

  options.context.io.out(`Generated policy types at ${resolvedOut}`);
  return 0;
}

export function generatePolicyTypes(policy: PolicySet, rawPolicy?: unknown): string {
  const { actionPatterns, actionNames, unresolvedActionPatterns } = extractActionNames(policy);
  const resourceTypes = extractResourceTypes(policy);
  const fieldGroups = extractFieldGroups(rawPolicy);

  const lines: string[] = [];
  lines.push('/* eslint-disable */');
  lines.push('// Generated by acx types. Do not edit manually.');
  lines.push('');
  lines.push(`export const POLICY_VERSION = '${escapeSingle(policy.policyVersion)}' as const;`);
  lines.push('');

  lines.push(`export const ACTION_PATTERNS = ${asConstArray(actionPatterns)};`);
  lines.push(`export type ActionPattern = typeof ACTION_PATTERNS[number];`);
  lines.push('');

  lines.push(`export const ACTION_NAMES = ${asConstArray(actionNames)};`);
  lines.push(`export type ActionName = typeof ACTION_NAMES[number];`);
  lines.push('');

  lines.push(`export const RESOURCE_TYPES = ${asConstArray(resourceTypes)};`);
  lines.push(`export type ResourceType = typeof RESOURCE_TYPES[number];`);

  if (unresolvedActionPatterns.length > 0) {
    lines.push('');
    lines.push(
      `export const UNRESOLVED_ACTION_PATTERNS = ${asConstArray(unresolvedActionPatterns)};`,
    );
  }

  if (fieldGroups) {
    lines.push('');
    lines.push(`export const FIELD_GROUPS = ${toStableObjectLiteral(fieldGroups)} as const;`);
    lines.push('export type FieldGroupName = keyof typeof FIELD_GROUPS;');
    lines.push(
      'export type FieldGroupFields<T extends FieldGroupName> = (typeof FIELD_GROUPS)[T][number];',
    );
  }

  lines.push('');
  return lines.join('\n');
}

function extractActionNames(policy: PolicySet): {
  actionPatterns: string[];
  actionNames: string[];
  unresolvedActionPatterns: string[];
} {
  const patternSet = new Set<string>();
  const exactSet = new Set<string>();

  for (const rule of policy.rules) {
    for (const action of rule.actions) {
      patternSet.add(action);
      if (!isWildcard(action)) {
        exactSet.add(action);
      }
    }
  }

  for (const role of policy.roles ?? []) {
    for (const permission of role.permissions) {
      for (const action of permission.actions) {
        patternSet.add(action);
        if (!isWildcard(action)) {
          exactSet.add(action);
        }
      }
    }
  }

  const actionPatterns = Array.from(patternSet).sort();
  const exactActions = Array.from(exactSet).sort();

  const expanded = new Set<string>(exactActions);
  const unresolved = new Set<string>();

  for (const pattern of actionPatterns) {
    if (!isWildcard(pattern)) {
      continue;
    }

    const matches = exactActions.filter((item) => matchesPattern(item, pattern));

    if (matches.length === 0) {
      unresolved.add(pattern);
      expanded.add(pattern);
      continue;
    }

    for (const match of matches) {
      expanded.add(match);
    }
  }

  const actionNames = Array.from(expanded).sort();

  return {
    actionPatterns,
    actionNames,
    unresolvedActionPatterns: Array.from(unresolved).sort(),
  };
}

function extractResourceTypes(policy: PolicySet): string[] {
  const resourceTypes = new Set<string>();
  let hasAny = false;

  const collectFromPermission = (permission: Pick<RolePermission, 'resourceTypes'>): void => {
    for (const resourceType of permission.resourceTypes) {
      if (resourceType === '*') {
        hasAny = true;
        continue;
      }
      resourceTypes.add(resourceType);
    }
  };

  for (const rule of policy.rules) {
    collectFromPermission({ resourceTypes: rule.resourceTypes });
  }

  for (const role of policy.roles ?? []) {
    for (const permission of role.permissions) {
      collectFromPermission(permission);
    }
  }

  if (resourceTypes.size === 0 && hasAny) {
    return ['*'];
  }

  return Array.from(resourceTypes).sort();
}

function extractFieldGroups(rawPolicy: unknown): Record<string, readonly string[]> | undefined {
  if (!rawPolicy || typeof rawPolicy !== 'object') {
    return undefined;
  }

  const groupsValue = (rawPolicy as Record<string, unknown>)['fieldGroups'];
  if (!groupsValue || typeof groupsValue !== 'object' || Array.isArray(groupsValue)) {
    return undefined;
  }

  const groupsRecord = groupsValue as Record<string, unknown>;
  const normalized: Record<string, readonly string[]> = {};

  for (const key of Object.keys(groupsRecord).sort()) {
    const value = groupsRecord[key];
    if (!Array.isArray(value)) {
      continue;
    }

    const fields = value.filter((item): item is string => typeof item === 'string').sort();

    normalized[key] = Array.from(new Set(fields));
  }

  if (Object.keys(normalized).length === 0) {
    return undefined;
  }

  return normalized;
}

function asConstArray(items: string[]): string {
  if (items.length === 0) {
    return '[] as const';
  }

  const quoted = items.map((item) => `'${escapeSingle(item)}'`).join(', ');
  return `[${quoted}] as const`;
}

function toStableObjectLiteral(value: Record<string, readonly string[]>): string {
  const parsed = JSON.parse(stableStringify(value)) as Record<string, readonly string[]>;
  return JSON.stringify(parsed, null, 2);
}

function isWildcard(value: string): boolean {
  return value.includes('*');
}

function matchesPattern(action: string, pattern: string): boolean {
  if (pattern === '*') {
    return true;
  }

  if (!pattern.endsWith('*')) {
    return action === pattern;
  }

  const prefix = pattern.slice(0, -1);
  return action.startsWith(prefix);
}

function escapeSingle(value: string): string {
  return value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}
